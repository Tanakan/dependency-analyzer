<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dependencies Analyzer</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        
        .header {
            background-color: #333;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        .input-section {
            background-color: white;
            padding: 1rem;
            margin: 1rem;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .input-section input {
            width: 60%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .input-section button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .input-section button:hover {
            background-color: #0056b3;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .error {
            display: none;
            background-color: #f8d7da;
            color: #721c24;
            padding: 1rem;
            margin: 1rem;
            border-radius: 5px;
        }
        
        .container {
            display: none;
            flex-direction: row;
            height: calc(100vh - 250px);
        }
        
        .nav-buttons {
            background-color: #444;
            padding: 0.5rem;
            text-align: center;
        }
        
        .nav-buttons a {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            margin: 0 0.5rem;
            background-color: #555;
            border-radius: 4px;
            display: inline-block;
        }
        
        .nav-buttons a:hover {
            background-color: #666;
        }
        
        .nav-buttons a.active {
            background-color: #007bff;
        }
        
        .sidebar {
            width: 350px;
            background-color: #f8f9fa;
            padding: 1rem;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }
        
        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .main {
            flex: 1;
            position: relative;
        }
        
        #graph {
            width: 100%;
            height: 100%;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node circle,
        .node rect {
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
        }
        
        .node text {
            font-size: 12px;
            pointer-events: none;
        }
        
        .node.hidden {
            display: none;
        }
        
        .node.highlighted circle,
        .node.highlighted rect {
            stroke-width: 4px;
            stroke: #ff6b6b;
        }
        
        .link {
            fill: none;
            stroke: #999;
            stroke-opacity: 0.4;
            stroke-width: 2px;
            stroke-linecap: round;
            marker-end: url(#arrowhead);
        }
        
        .link.hidden {
            display: none;
        }
        
        .link.highlighted {
            stroke-opacity: 0.8;
            stroke-width: 3px;
        }
        
        .repo-group-container.hidden {
            display: none;
        }
        
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 8px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
        }
        
        .info-section {
            margin-bottom: 1.5rem;
        }
        
        .info-section h3 {
            margin-bottom: 0.5rem;
            color: #333;
        }
        
        .repository-group {
            margin-bottom: 1rem;
            background-color: #f5f5f5;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .repository-header {
            padding: 0.75rem;
            background-color: #e9ecef;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .repository-header .chevron {
            transition: transform 0.2s;
            margin-right: 8px;
        }
        
        .repository-header.collapsed .chevron {
            transform: rotate(-90deg);
        }
        
        .repository-group.collapsed .project-list {
            display: none;
        }
        
        .repository-header:hover {
            background-color: #dee2e6;
        }
        
        .repository-header.selected {
            background-color: #007bff;
            color: white;
        }
        
        .project-count {
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
        }
        
        .repository-header.selected .project-count {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        .project-list {
            padding: 0.5rem;
        }
        
        .project-item {
            padding: 0.5rem 0.75rem;
            margin: 0.25rem 0;
            background-color: white;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        
        .project-item:hover {
            background-color: #f8f9fa;
            transform: translateX(2px);
        }
        
        .project-item.selected {
            background-color: #007bff;
            color: white;
            transform: translateX(4px);
        }
        
        .project-item.selected span {
            opacity: 0.9;
        }
        
        .node.filtered-out {
            opacity: 0.15;
            pointer-events: none;
        }
        
        .link.filtered-out {
            opacity: 0.08;
            pointer-events: none;
        }
        
        .clear-filter {
            margin-bottom: 10px;
            padding: 5px 10px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
        }
        
        .clear-filter:hover {
            background-color: #5a6268;
        }
        
        .centering-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.9; }
            50% { opacity: 0.6; }
            100% { opacity: 0.9; }
        }
        
        
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-symbol {
            width: 30px;
            height: 30px;
            margin-right: 10px;
        }
        
        
        h4:hover {
            background-color: #f0f0f0;
        }
        
        .repo-group {
            fill: #f5f5f5;
            fill-opacity: 0.9;
            stroke: #666666;
            stroke-width: 4px;
            stroke-dasharray: 15,5;
            rx: 20;
            ry: 20;
        }
        
        .repo-group-label {
            font-size: 18px;
            font-weight: bold;
            fill: #333333;
            text-anchor: start;
            font-family: Arial, sans-serif;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        
        .groups-layer, .static-groups-layer {
            pointer-events: all;
        }
        
        .repo-group {
            cursor: move;
            transition: filter 0.2s;
        }
        
        .repo-group:hover {
            stroke-opacity: 0.8;
            filter: brightness(1.1);
        }
        
        .repo-group.dragging {
            filter: brightness(1.2) drop-shadow(0 5px 10px rgba(0,0,0,0.3));
            stroke-width: 6px !important;
        }
        
        .repo-group.collision-warning {
            stroke: #ff5252 !important;
            stroke-width: 6px !important;
            stroke-dasharray: 10,5 !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Dependencies Analyzer</h1>
    </div>
    
    <div class="nav-buttons">
        <a href="index.html" class="active">Dependency Graph</a>
        <a href="cohesion.html">Cohesion Analysis</a>
        <a href="issues.html">Issues Analysis</a>
        <a href="dependency-impact.html">Dependency Impact</a>
    </div>
    
    <div class="input-section">
        <h3>Dependency Analysis Results</h3>
        <div style="margin-top: 10px; font-size: 14px; color: #666;">
            Automatically loaded from dependencies-analysis.json file
        </div>
        <div style="margin-top: 10px;">
            <span id="group-status" style="color: #666; font-size: 14px; font-weight: bold;">Repository frames are always visible with no overlaps (Grid Layout)</span>
        </div>
    </div>
    
    <div class="loading">
        <p>Analyzing...</p>
    </div>
    
    <div class="error" id="errorMessage"></div>
    
    <div class="container" id="graphContainer">
        <div class="sidebar">
            <div class="info-section">
                <h3>Statistics</h3>
                <div id="stats"></div>
            </div>
            
            <div class="info-section">
                <h3>Project List</h3>
                <div id="project-list"></div>
            </div>
        </div>
        
        <div class="main">
            <svg id="graph"></svg>
            <div class="tooltip"></div>
            <div class="legend">
                <h4 style="margin-top: 0; margin-bottom: 10px;">Package Type</h4>
                <div class="legend-item">
                    <svg class="legend-symbol" viewBox="0 0 30 30">
                        <circle cx="15" cy="15" r="12" fill="#7f7f7f" stroke="#4ecdc4" stroke-width="2"/>
                    </svg>
                    <span>JAR - Java Archive</span>
                </div>
                <div class="legend-item">
                    <svg class="legend-symbol" viewBox="0 0 30 30">
                        <rect x="3" y="3" width="24" height="24" fill="#7f7f7f" stroke="#ff6b6b" stroke-width="3"/>
                    </svg>
                    <span>WAR - Web Archive</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="centering-indicator" id="centeringIndicator">
        Navigating to filtered nodes...
    </div>
    
    <script>
        let svg, g, simulation, zoom;
        let currentData = null;
        let selectedProject = null;
        let groupsVisible = true;
        let allProjectRepos = [];
        let isGridLayout = false;
        let gridParameters = null;
        let repositoryLayoutData = []; // New data structure for repository rectangles
        let gridCols = 6;
        let gridRows = 1;
        
        // Automatically load data when page loads
        window.addEventListener('DOMContentLoaded', function() {
            loadAnalysisData();
            
        });
        
        function loadAnalysisData() {
            document.querySelector('.loading').style.display = 'block';
            document.querySelector('.error').style.display = 'none';
            document.getElementById('graphContainer').style.display = 'none';
            
            fetch('/api/dependencies-analysis')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to load data');
                }
                return response.json();
            })
            .then(data => {
                document.querySelector('.loading').style.display = 'none';
                
                if (data.error) {
                    showError(data.error);
                } else {
                    currentData = data;
                    displayGraph(data);
                }
            })
            .catch(error => {
                document.querySelector('.loading').style.display = 'none';
                showError('Error occurred: ' + error.message);
            });
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        function displayGraph(data) {
            try {
                document.getElementById('graphContainer').style.display = 'flex';
                
                // Clear previous graph
                d3.select("#graph").selectAll("*").remove();
                
                // Reset grid layout flag and data
                isGridLayout = false;
                gridParameters = null;
                repositoryLayoutData = [];
            
            // Set up SVG
            svg = d3.select("#graph");
            const width = svg.node().parentElement.clientWidth;
            const height = svg.node().parentElement.clientHeight;
            
            svg.attr("width", width).attr("height", height);
            
            // Create arrow marker
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "-0 -5 10 10")
                .attr("refX", 25)
                .attr("refY", 0)
                .attr("orient", "auto")
                .attr("markerWidth", 8)
                .attr("markerHeight", 8)
                .append("path")
                .attr("d", "M 0,-5 L 10 ,0 L 0,5")
                .attr("fill", "#999");
            
            // Create zoom behavior with higher max scale for closer zoom
            zoom = d3.zoom()
                .scaleExtent([0.1, 20])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                    // Also apply transform to static groups layer so they pan/zoom but don't move with simulation
                    d3.select(".static-groups-layer").attr("transform", event.transform);
                });
            
            svg.call(zoom);
            
            // Create a separate layer for repository frames that won't be affected by zoom/pan
            const staticGroupsLayer = svg.append("g").attr("class", "static-groups-layer");
            
            g = svg.append("g");
            
            // Create groups layer (behind everything) - for dynamic groups only
            const groupsLayer = g.append("g").attr("class", "groups-layer");
            g.node().insertBefore(groupsLayer.node(), g.node().firstChild);
            
            // Validate nodes - ensure all have required properties
            data.nodes = data.nodes.filter(node => {
                if (!node.id || !node.nodeGroup) {
                    console.warn(`Removing invalid node:`, node);
                    return false;
                }
                // Initialize positions if not present
                if (node.x === undefined) node.x = 0;
                if (node.y === undefined) node.y = 0;
                return true;
            });
            
            // Validate links - remove any links with invalid source/target
            const nodeIds = new Set(data.nodes.map(n => n.id));
            data.links = data.links.filter(link => {
                if (!nodeIds.has(link.source) || !nodeIds.has(link.target)) {
                    console.warn(`Removing invalid link: source=${link.source}, target=${link.target}`);
                    return false;
                }
                return true;
            });
            
            // Find repositories with multiple projects
            const projectsByRepo = {};
            data.nodes.forEach(node => {
                if (!projectsByRepo[node.nodeGroup]) {
                    projectsByRepo[node.nodeGroup] = [];
                }
                projectsByRepo[node.nodeGroup].push(node);
            });
            
            allProjectRepos = Object.entries(projectsByRepo)
                .map(([repo, projects]) => ({
                    repository: repo,
                    projects: projects
                }));
            
            console.log('All repositories found:', allProjectRepos.length);
            console.log('Repositories:', allProjectRepos.map(r => `${r.repository} (${r.projects.length} projects)`));
            
            // Calculate repository positions to avoid overlaps
            let repoPositions = calculateRepositoryPositions(projectsByRepo, width, height);
            
            // Always start with grid layout to prevent overlaps
            isGridLayout = true;
            
            // Calculate repository connection matrix
            const repoConnectionMatrix = {};
            const repos = Object.entries(projectsByRepo);
            const repoNames = repos.map(([name]) => name);
            
            // Initialize matrix
            repoNames.forEach(repo1 => {
                repoConnectionMatrix[repo1] = {};
                repoNames.forEach(repo2 => {
                    repoConnectionMatrix[repo1][repo2] = 0;
                });
            });
            
            // Count connections between repositories
            data.links.forEach(link => {
                const sourceNode = data.nodes.find(n => n.id === link.source);
                const targetNode = data.nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode) {
                    const sourceRepo = sourceNode.nodeGroup;
                    const targetRepo = targetNode.nodeGroup;
                    
                    if (sourceRepo !== targetRepo) {
                        repoConnectionMatrix[sourceRepo][targetRepo]++;
                        repoConnectionMatrix[targetRepo][sourceRepo]++; // Bidirectional
                    }
                }
            });
            
            // Calculate total connections for each repository
            const repoConnections = {};
            repoNames.forEach(repo => {
                let totalConnections = 0;
                repoNames.forEach(otherRepo => {
                    if (repo !== otherRepo) {
                        totalConnections += repoConnectionMatrix[repo][otherRepo];
                    }
                });
                repoConnections[repo] = totalConnections;
            });
            
            // Use force simulation to position repositories
            const repoNodes = repos.map(([name, nodes]) => ({
                id: name,
                nodeCount: nodes.length,
                connections: repoConnections[name] || 0
            }));
            
            // Debug: Show top connected repositories
            const sortedByConnections = [...repoNodes].sort((a, b) => b.connections - a.connections);
            console.log('Top connected repositories:');
            sortedByConnections.slice(0, 10).forEach(repo => {
                console.log(`  ${repo.id}: ${repo.connections} connections, ${repo.nodeCount} nodes`);
            });
            
            const repoLinks = [];
            repoNames.forEach((repo1, i) => {
                repoNames.forEach((repo2, j) => {
                    if (i < j && repoConnectionMatrix[repo1][repo2] > 0) {
                        repoLinks.push({
                            source: repo1,
                            target: repo2,
                            value: repoConnectionMatrix[repo1][repo2]
                        });
                    }
                });
            });
            
            // Create force simulation for repository layout
            const repoSimulation = d3.forceSimulation(repoNodes)
                .force("link", d3.forceLink(repoLinks)
                    .id(d => d.id)
                    .distance(d => 400 - d.value * 20) // Closer if more connections
                    .strength(d => Math.min(1, d.value * 0.2)))
                .force("charge", d3.forceManyBody()
                    .strength(d => -500 - d.nodeCount * 50)) // Stronger repulsion for larger repos
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide()
                    .radius(d => 150 + d.nodeCount * 15))
                .stop();
            
            // Run simulation
            for (let i = 0; i < 300; i++) {
                repoSimulation.tick();
            }
            
            // Apply grid snapping to avoid overlaps
            const cellWidth = 350;
            const cellHeight = 280;
            const cellMargin = 25;
            const minMargin = 50;
            
            // Sort repositories by position for consistent grid assignment
            const sortedRepoNodes = [...repoNodes].sort((a, b) => {
                // Primary sort by y position (row)
                const rowA = Math.floor(a.y / cellHeight);
                const rowB = Math.floor(b.y / cellHeight);
                if (rowA !== rowB) return rowA - rowB;
                // Secondary sort by x position (column)
                return a.x - b.x;
            });
            
            // Calculate grid dimensions based on repository positions
            const minX = Math.min(...sortedRepoNodes.map(n => n.x));
            const maxX = Math.max(...sortedRepoNodes.map(n => n.x));
            const minY = Math.min(...sortedRepoNodes.map(n => n.y));
            const maxY = Math.max(...sortedRepoNodes.map(n => n.y));
            
            gridCols = Math.max(3, Math.min(6, Math.ceil((maxX - minX) / cellWidth)));
            gridRows = Math.ceil(sortedRepoNodes.length / gridCols);
            
            // Calculate offsets to center the grid
            const gridWidth = gridCols * cellWidth;
            const gridHeight = gridRows * cellHeight;
            const offsetX = Math.max(minMargin, (width - gridWidth) / 2);
            const offsetY = Math.max(minMargin, (height - gridHeight) / 2);
            
            // Assign grid positions while maintaining relative positions
            const gridPositions = new Array(gridRows).fill(null).map(() => new Array(gridCols).fill(null));
            const repoGridPositions = {};
            
            sortedRepoNodes.forEach(repoNode => {
                // Find best grid position based on force simulation result
                const idealCol = Math.floor((repoNode.x - minX) / (maxX - minX) * (gridCols - 1));
                const idealRow = Math.floor((repoNode.y - minY) / (maxY - minY) * (gridRows - 1));
                
                // Find nearest available position
                let bestCol = idealCol;
                let bestRow = idealRow;
                let minDistance = Infinity;
                
                for (let r = 0; r < gridRows; r++) {
                    for (let c = 0; c < gridCols; c++) {
                        if (!gridPositions[r][c]) {
                            const distance = Math.abs(r - idealRow) + Math.abs(c - idealCol);
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestRow = r;
                                bestCol = c;
                            }
                        }
                    }
                }
                
                gridPositions[bestRow][bestCol] = repoNode.id;
                repoGridPositions[repoNode.id] = { row: bestRow, col: bestCol };
            });
            
            // Pre-calculate all repository positions
            repositoryLayoutData = [];
            repos.forEach(([repo, nodes]) => {
                const gridPos = repoGridPositions[repo];
                if (!gridPos) return;
                
                const col = gridPos.col;
                const row = gridPos.row;
                
                const cellLeft = offsetX + col * cellWidth;
                const cellTop = offsetY + row * cellHeight;
                const cellCenterX = cellLeft + cellWidth / 2;
                const cellCenterY = cellTop + cellHeight / 2;
                
                repositoryLayoutData.push({
                    name: repo,
                    nodes: nodes,
                    rect: {
                        x: cellLeft + cellMargin,
                        y: cellTop + cellMargin,
                        width: cellWidth - 2 * cellMargin,
                        height: cellHeight - 2 * cellMargin
                    }
                });
                
                // Calculate node degrees (number of connections)
                const nodeDegrees = new Map();
                nodes.forEach(node => {
                    const degree = data.links.filter(l => l.source === node.id || l.target === node.id).length;
                    nodeDegrees.set(node.id, degree);
                });
                
                // Calculate connection scores for smarter positioning
                const connectionScores = new Map();
                nodes.forEach(node => {
                    let score = 0;
                    let externalConnections = 0;
                    let internalConnections = 0;
                    
                    data.links.forEach(link => {
                        if (link.source === node.id || link.target === node.id) {
                            const otherNodeId = link.source === node.id ? link.target : link.source;
                            const otherNode = data.nodes.find(n => n.id === otherNodeId);
                            
                            if (otherNode) {
                                if (otherNode.nodeGroup === node.nodeGroup) {
                                    internalConnections++;
                                    score += 2; // Internal connections are more important for positioning
                                } else {
                                    externalConnections++;
                                    score += 1;
                                }
                            }
                        }
                    });
                    
                    connectionScores.set(node.id, {
                        total: score,
                        internal: internalConnections,
                        external: externalConnections
                    });
                });
                
                // Sort nodes by connection score (highest first) - highly connected nodes go to center
                const sortedNodes = [...nodes].sort((a, b) => {
                    const scoreA = connectionScores.get(a.id)?.total || 0;
                    const scoreB = connectionScores.get(b.id)?.total || 0;
                    return scoreB - scoreA;
                });
                
                // Set initial positions with no overlap using grid layout
                const nodeRadius = 15; // Node visual radius
                const labelHeight = 35; // Space needed for text below node
                const minNodeSpacing = 80; // Increased spacing to account for node + label
                const cellPadding = 50; // Increased padding from cell edges
                
                if (nodes.length === 1) {
                    if (nodes[0]) {
                        nodes[0].x = cellCenterX;
                        nodes[0].y = cellCenterY;
                    }
                } else if (nodes.length === 2) {
                    // Two nodes: place horizontally
                    if (sortedNodes[0]) {
                        sortedNodes[0].x = cellCenterX - minNodeSpacing / 2;
                        sortedNodes[0].y = cellCenterY;
                    }
                    if (sortedNodes[1]) {
                        sortedNodes[1].x = cellCenterX + minNodeSpacing / 2;
                        sortedNodes[1].y = cellCenterY;
                    }
                } else {
                    // Multiple nodes: use radial layout with most connected node in center
                    const availableWidth = cellWidth - 2 * cellPadding;
                    const availableHeight = cellHeight - 2 * cellPadding;
                    
                    if (nodes.length <= 6) {
                        // For small groups, place highest connected node in center
                        // and others in a circle around it
                        const centerNode = sortedNodes[0];
                        if (centerNode) {
                            centerNode.x = cellCenterX;
                            centerNode.y = cellCenterY;
                        }
                        
                        if (nodes.length > 1) {
                            const radius = Math.min(availableWidth, availableHeight) * 0.35;
                            const angleStep = (2 * Math.PI) / (nodes.length - 1);
                            
                            for (let i = 1; i < sortedNodes.length; i++) {
                                const angle = (i - 1) * angleStep - Math.PI / 2; // Start from top
                                if (sortedNodes[i]) {
                                    sortedNodes[i].x = cellCenterX + radius * Math.cos(angle);
                                    sortedNodes[i].y = cellCenterY + radius * Math.sin(angle);
                                }
                            }
                        }
                    } else {
                        // For larger groups, use concentric circles
                        const maxRadius = Math.min(availableWidth, availableHeight) * 0.4;
                        let nodeIndex = 0;
                        let ring = 0;
                        
                        // Place most connected node at center
                        if (sortedNodes[0]) {
                            sortedNodes[0].x = cellCenterX;
                            sortedNodes[0].y = cellCenterY;
                        }
                        nodeIndex = 1;
                        
                        // Place remaining nodes in concentric rings
                        while (nodeIndex < sortedNodes.length) {
                            ring++;
                            const ringRadius = (maxRadius * ring) / 3;
                            const nodesInRing = Math.min(
                                ring * 6, // Each ring can hold 6 more nodes than the previous
                                sortedNodes.length - nodeIndex
                            );
                            
                            if (nodesInRing > 0) {
                                const angleStep = (2 * Math.PI) / nodesInRing;
                                
                                for (let i = 0; i < nodesInRing && nodeIndex < sortedNodes.length; i++) {
                                    const angle = i * angleStep - Math.PI / 2;
                                    if (sortedNodes[nodeIndex]) {
                                        sortedNodes[nodeIndex].x = cellCenterX + ringRadius * Math.cos(angle);
                                        sortedNodes[nodeIndex].y = cellCenterY + ringRadius * Math.sin(angle);
                                    }
                                    nodeIndex++;
                                }
                            } else {
                                break; // Safety check - should not happen but prevents infinite loop
                            }
                        }
                    }
                    
                    // Ensure all nodes stay within bounds
                    sortedNodes.forEach(node => {
                        const minX = cellLeft + cellPadding;
                        const maxX = cellLeft + cellWidth - cellPadding;
                        const minY = cellTop + cellPadding;
                        const maxY = cellTop + cellHeight - cellPadding;
                        
                        node.x = Math.max(minX, Math.min(maxX, node.x));
                        node.y = Math.max(minY, Math.min(maxY, node.y));
                    });
                    
                    // Fix any remaining overlaps by slightly adjusting positions
                    for (let i = 0; i < sortedNodes.length; i++) {
                        for (let j = i + 1; j < sortedNodes.length; j++) {
                            const node1 = sortedNodes[i];
                            const node2 = sortedNodes[j];
                            const dx = node2.x - node1.x;
                            const dy = node2.y - node1.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < minNodeSpacing) {
                                // Nodes are too close, push them apart
                                const angle = Math.atan2(dy, dx);
                                const pushDistance = (minNodeSpacing - distance) / 2 + 1;
                                
                                node1.x -= Math.cos(angle) * pushDistance;
                                node1.y -= Math.sin(angle) * pushDistance;
                                node2.x += Math.cos(angle) * pushDistance;
                                node2.y += Math.sin(angle) * pushDistance;
                                
                                // Keep within bounds
                                const minX = cellLeft + cellPadding;
                                const maxX = cellLeft + cellWidth - cellPadding;
                                const minY = cellTop + cellPadding;
                                const maxY = cellTop + cellHeight - cellPadding;
                                
                                node1.x = Math.max(minX, Math.min(maxX, node1.x));
                                node1.y = Math.max(minY, Math.min(maxY, node1.y));
                                node2.x = Math.max(minX, Math.min(maxX, node2.x));
                                node2.y = Math.max(minY, Math.min(maxY, node2.y));
                            }
                        }
                    }
                }
            });
            
            // Create force simulation but don't start it
            simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.links).id(d => d.id)
                    .distance(100)  // Much larger distance for very loose links
                    .strength(0.01)) // Extremely low strength to reduce tension
                .force("charge", d3.forceManyBody().strength(-50)) // Much reduced repulsion
                .force("collision", d3.forceCollide().radius(40))
                .force("repositoryBounds", forceRepositoryBounds()) // Custom force to keep nodes within their repository
                .stop(); // Stop immediately - don't run simulation at all
            
            // Group links by source and target repositories for bundling
            const linkGroups = {};
            data.links.forEach(link => {
                // At this point, link.source and link.target are still string IDs
                const sourceNode = data.nodes.find(n => n.id === link.source);
                const targetNode = data.nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode) {
                    const sourceRepo = sourceNode.nodeGroup;
                    const targetRepo = targetNode.nodeGroup;
                    
                    if (sourceRepo && targetRepo) {
                        const key = sourceRepo === targetRepo ? `internal-${sourceRepo}` : `${sourceRepo}->${targetRepo}`;
                        if (!linkGroups[key]) {
                            linkGroups[key] = [];
                        }
                        linkGroups[key].push(link);
                    }
                }
            });
            
            // Create links with smart routing
            const link = g.append("g")
                .selectAll("path")
                .data(data.links)
                .enter().append("path")
                .attr("class", "link")
                .attr("fill", "none")
                .attr("d", d => {
                    const sourceNode = typeof d.source === 'object' ? d.source : data.nodes.find(n => n.id === d.source);
                    const targetNode = typeof d.target === 'object' ? d.target : data.nodes.find(n => n.id === d.target);
                    
                    if (!sourceNode || !targetNode) return "";
                    
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Different curves for internal vs external links
                    if (sourceNode.nodeGroup === targetNode.nodeGroup) {
                        // Internal links: smaller curves
                        const dr = distance * 0.5;
                        return `M${sourceNode.x},${sourceNode.y} Q${(sourceNode.x + targetNode.x) / 2},${(sourceNode.y + targetNode.y) / 2 + dr / 3} ${targetNode.x},${targetNode.y}`;
                    } else {
                        // External links: larger curves for better separation
                        const dr = distance * 0.8;
                        // Add slight offset based on link direction to separate bidirectional links
                        const offset = sourceNode.id < targetNode.id ? -10 : 10;
                        const midX = (sourceNode.x + targetNode.x) / 2 + offset * dy / distance;
                        const midY = (sourceNode.y + targetNode.y) / 2 - offset * dx / distance;
                        return `M${sourceNode.x},${sourceNode.y} Q${midX},${midY + dr / 2} ${targetNode.x},${targetNode.y}`;
                    }
                });
            
            // Create nodes with drag functionality
            const node = g.append("g")
                .selectAll("g")
                .data(data.nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`) // Position immediately
                .on("click", function(event, d) {
                    event.stopPropagation();
                    highlightConnectedNodes(d, data);
                })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            // Color scale for different repositories
            const color = d3.scaleOrdinal(d3.schemeCategory10);
            
            // Add different shapes for WAR and JAR
            node.each(function(d) {
                const nodeElement = d3.select(this);
                
                if (d.packaging === 'war') {
                    // Square for WAR files
                    nodeElement.append("rect")
                        .attr("x", -12)
                        .attr("y", -12)
                        .attr("width", 24)
                        .attr("height", 24)
                        .attr("fill", color(d.nodeGroup))
                        .attr("stroke", "#ff6b6b")
                        .attr("stroke-width", 3);
                } else {
                    // Circle for JAR files (default)
                    nodeElement.append("circle")
                        .attr("r", 12)
                        .attr("fill", color(d.nodeGroup))
                        .attr("stroke", "#4ecdc4")
                        .attr("stroke-width", 2);
                }
            });
            
            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", 30)  // Position further below the node to avoid overlap
                .style("font-size", "11px")
                .text(d => d.name);
            
            // Add packaging type label with background
            const labelGroup = node.append("g")
                .attr("transform", "translate(0, -20)");
            
            labelGroup.append("rect")
                .attr("x", -15)
                .attr("y", -8)
                .attr("width", 30)
                .attr("height", 16)
                .attr("rx", 3)
                .attr("fill", d => d.packaging === 'war' ? "#ff6b6b" : "#4ecdc4")
                .attr("opacity", 0.9);
            
            labelGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", 3)
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .attr("fill", "white")
                .text(d => d.packaging ? d.packaging.toUpperCase() : 'JAR');
            
            // Tooltip
            const tooltip = d3.select(".tooltip");
            
            node.on("mouseover", (event, d) => {
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`
                    <strong>${d.name}</strong><br/>
                    Group: ${d.group}<br/>
                    Version: ${d.version}<br/>
                    Type: ${d.type}<br/>
                    Packaging: <strong>${d.packaging ? d.packaging.toUpperCase() : 'JAR'}</strong>
                `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", (d) => {
                tooltip.transition().duration(500).style("opacity", 0);
            });
            
            // Update positions on tick
            simulation.on("tick", () => {
                // Update links with smart routing
                link.attr("d", d => {
                    const sourceNode = d.source;
                    const targetNode = d.target;
                    
                    if (!sourceNode || !targetNode) return "";
                    
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Different curves for internal vs external links
                    if (sourceNode.nodeGroup === targetNode.nodeGroup) {
                        // Internal links: smaller curves
                        const dr = distance * 0.5;
                        return `M${sourceNode.x},${sourceNode.y} Q${(sourceNode.x + targetNode.x) / 2},${(sourceNode.y + targetNode.y) / 2 + dr / 3} ${targetNode.x},${targetNode.y}`;
                    } else {
                        // External links: larger curves for better separation
                        const dr = distance * 0.8;
                        // Add slight offset based on link direction to separate bidirectional links
                        const offset = sourceNode.id < targetNode.id ? -10 : 10;
                        const midX = (sourceNode.x + targetNode.x) / 2 + offset * dy / distance;
                        const midY = (sourceNode.y + targetNode.y) / 2 - offset * dx / distance;
                        return `M${sourceNode.x},${sourceNode.y} Q${midX},${midY + dr / 2} ${targetNode.x},${targetNode.y}`;
                    }
                });
                
                node.attr("transform", d => `translate(${d.x},${d.y})`);
                
                // Do NOT update repository groups here - they should remain fixed
            });
            
            
            // No simulation updates needed since we stopped it
            
            // Function to draw repository groups
            function updateRepositoryGroups() {
                if (!groupsVisible) return;
                const groups = groupsLayer.selectAll(".repo-group-container")
                    .data(allProjectRepos);
                
                const groupEnter = groups.enter()
                    .append("g")
                    .attr("class", "repo-group-container");
                
                groupEnter.append("rect")
                    .attr("class", "repo-group");
                
                groupEnter.append("text")
                    .attr("class", "repo-group-label");
                
                groups.merge(groupEnter).each(function(d) {
                    const group = d3.select(this);
                    const nodes = d.projects;
                    
                    if (nodes.some(n => n.x === undefined || n.y === undefined)) {
                        return; // Skip if positions not yet initialized
                    }
                    
                    // Calculate bounding box with appropriate padding
                    const padding = nodes.length > 1 ? 40 : 25;
                    const xs = nodes.map(n => n.x);
                    const ys = nodes.map(n => n.y);
                    const minX = Math.min(...xs) - padding;
                    const maxX = Math.max(...xs) + padding;
                    const minY = Math.min(...ys) - padding;
                    const maxY = Math.max(...ys) + padding;
                    
                    // Update rectangle
                    group.select(".repo-group")
                        .attr("x", minX)
                        .attr("y", minY)
                        .attr("width", maxX - minX)
                        .attr("height", maxY - minY)
                        .attr("rx", 15)
                        .attr("ry", 15);
                    
                    // Update label with background
                    const labelGroup = group.selectAll(".repo-label-group").data([d]);
                    const labelGroupEnter = labelGroup.enter()
                        .append("g")
                        .attr("class", "repo-label-group");
                    
                    labelGroupEnter.append("rect")
                        .attr("class", "repo-label-bg")
                        .attr("fill", "white")
                        .attr("stroke", "#666666")
                        .attr("stroke-width", 2)
                        .attr("rx", 5)
                        .attr("ry", 5);
                    
                    labelGroupEnter.append("text")
                        .attr("class", "repo-group-label");
                    
                    const label = group.select(".repo-group-label")
                        .attr("x", minX + 10)
                        .attr("y", minY - 10)
                        .text(d.repository);
                    
                    // Update label background
                    const bbox = label.node().getBBox();
                    group.select(".repo-label-bg")
                        .attr("x", bbox.x - 5)
                        .attr("y", bbox.y - 3)
                        .attr("width", bbox.width + 10)
                        .attr("height", bbox.height + 6);
                });
            }
            
            updateSidebar(data, color);
            
            // Draw repository frames immediately
            forceUpdateGroups();
            
            // Apply zoom if needed to show all repositories
            const totalWidth = gridCols * cellWidth + 100;
            const totalHeight = gridRows * cellHeight + 100;
            if (totalWidth > width || totalHeight > height) {
                const scaleX = width / totalWidth;
                const scaleY = height / totalHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9;
                
                const transform = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(scale)
                    .translate(-width / 2, -height / 2);
                
                svg.call(zoom.transform, transform);
            }
            
            // Add click handler to SVG to clear highlights
            svg.on("click", function(event) {
                // Only clear if clicking on background (not on nodes)
                if (event.target.tagName === 'svg' || event.target.classList.contains('repo-group')) {
                    clearHighlights();
                }
            });
            
            } catch (error) {
                console.error('Error in displayGraph:', error);
                showError('Failed to display graph: ' + error.message);
            }
        }
        
        // Function to find all dependencies required to build a project (transitive dependencies)
        function findBuildDependencies(nodeId, data) {
            console.log(`Finding build dependencies for: ${nodeId}`);
            const dependencies = new Set([nodeId]);
            const toProcess = [nodeId];
            
            while (toProcess.length > 0) {
                const current = toProcess.pop();
                console.log(`  Processing: ${current}`);
                
                // Find all nodes that the current node depends on
                // In the link format: source -> target means source depends on target
                data.links.forEach(link => {
                    // Handle both object and string formats
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    // If current node is the source (it depends on target), add target as dependency
                    if (sourceId === current) {
                        const dependency = targetId;
                        if (!dependencies.has(dependency)) {
                            console.log(`    ${current} depends on ${dependency}`);
                            dependencies.add(dependency);
                            toProcess.push(dependency);
                        }
                    }
                });
            }
            
            console.log(`Total dependencies for ${nodeId}:`, Array.from(dependencies));
            return dependencies;
        }
        
        // Function to highlight build dependencies
        function highlightConnectedNodes(clickedNode, data) {
            const buildDependencies = findBuildDependencies(clickedNode.id, data);
            
            // Update nodes - hide those not in build dependencies
            d3.selectAll('.node')
                .classed('highlighted', d => d.id === clickedNode.id)
                .classed('hidden', d => !buildDependencies.has(d.id));
            
            // Update links - hide those not part of the dependency chain
            d3.selectAll('.link')
                .classed('highlighted', d => {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    // Highlight if both nodes are in dependencies AND the link points TO a dependency
                    return buildDependencies.has(sourceId) && buildDependencies.has(targetId) && targetId !== clickedNode.id;
                })
                .classed('hidden', d => {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    return !buildDependencies.has(sourceId) || !buildDependencies.has(targetId);
                });
            
            // Hide repository frames that have no visible nodes
            d3.selectAll('.repo-group-container').each(function(d) {
                const hasVisibleNodes = d.nodes.some(node => buildDependencies.has(node.id));
                d3.select(this).classed('hidden', !hasVisibleNodes);
            });
        }
        
        // Function to clear highlights
        function clearHighlights() {
            d3.selectAll('.node')
                .classed('highlighted', false)
                .classed('hidden', false);
            
            d3.selectAll('.link')
                .classed('highlighted', false)
                .classed('hidden', false);
            
            d3.selectAll('.repo-group-container')
                .classed('hidden', false);
        }
        
        // Drag functions with repository boundary constraints
        function dragstarted(event, d) {
            // Don't restart simulation
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            // Find the repository bounds for this node
            const repoBounds = repositoryLayoutData.find(r => r.name === d.nodeGroup);
            const nodeRadius = 15;
            const labelHeight = 30;
            
            let newX = event.x;
            let newY = event.y;
            
            if (repoBounds) {
                const rect = repoBounds.rect;
                const padding = nodeRadius + 5;
                const bottomPadding = padding + labelHeight; // Extra space for label
                
                // Constrain dragged position to repository bounds
                newX = Math.max(rect.x + padding, Math.min(rect.x + rect.width - padding, newX));
                newY = Math.max(rect.y + padding + 20, Math.min(rect.y + rect.height - bottomPadding, newY));
                
                // Check collision with other nodes in the same repository
                const otherNodes = repoBounds.nodes.filter(n => n.id !== d.id);
                let hasCollision = true;
                let attempts = 0;
                const maxAttempts = 10;
                
                while (hasCollision && attempts < maxAttempts) {
                    hasCollision = false;
                    
                    for (const other of otherNodes) {
                        const dx = newX - other.x;
                        const dy = newY - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = 50; // Minimum distance to prevent label overlap
                        
                        if (distance < minDistance) {
                            hasCollision = true;
                            // Push the node away from the collision
                            const angle = Math.atan2(dy, dx);
                            const pushDistance = minDistance - distance + 1;
                            newX += Math.cos(angle) * pushDistance;
                            newY += Math.sin(angle) * pushDistance;
                            
                            // Re-constrain to bounds
                            newX = Math.max(rect.x + padding, Math.min(rect.x + rect.width - padding, newX));
                            newY = Math.max(rect.y + padding + 20, Math.min(rect.y + rect.height - padding, newY));
                            break;
                        }
                    }
                    attempts++;
                }
            }
            
            // Update position
            d.x = newX;
            d.y = newY;
            
            // Update node position immediately
            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            
            // Update connected links
            d3.selectAll('.link')
                .filter(l => l.source.id === d.id || l.target.id === d.id)
                .attr("d", linkData => {
                    const dx = linkData.target.x - linkData.source.x;
                    const dy = linkData.target.y - linkData.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 0.8;
                    return `M${linkData.source.x},${linkData.source.y} Q${(linkData.source.x + linkData.target.x) / 2},${(linkData.source.y + linkData.target.y) / 2 + dr / 2} ${linkData.target.x},${linkData.target.y}`;
                });
        }
        
        function dragended(event, d) {
            // Keep position fixed
            d.fx = d.x;
            d.fy = d.y;
        }
        
        
        // Update sidebar
        function updateSidebar(data, color) {
            // Stats
            const stats = document.getElementById("stats");
            stats.innerHTML = `
                <div class="project-item">
                    <strong>Total Projects:</strong> ${data.nodes.length}
                </div>
                <div class="project-item">
                    <strong>Total Dependencies:</strong> ${data.links.length}
                </div>
            `;
            
            // Project list
            const projectList = document.getElementById("project-list");
            const groupedProjects = {};
            
            data.nodes.forEach(node => {
                if (!groupedProjects[node.nodeGroup]) {
                    groupedProjects[node.nodeGroup] = [];
                }
                groupedProjects[node.nodeGroup].push(node);
            });
            
            let projectHtml = "";
            if (selectedProject) {
                projectHtml = '<button class="clear-filter" onclick="clearFilter()">Clear Filter</button>';
            }
            
            // Sort repositories by name
            const sortedRepos = Object.entries(groupedProjects).sort((a, b) => a[0].localeCompare(b[0]));
            
            sortedRepos.forEach(([group, projects]) => {
                const isGroupSelected = selectedProject && selectedProject.startsWith('group:') && selectedProject === `group:${group}`;
                const projectCount = projects.length;
                
                projectHtml += `
                    <div class="repository-group" id="repo-${group.replace(/[^a-zA-Z0-9]/g, '-')}">
                        <div class="repository-header ${isGroupSelected ? 'selected' : ''}" 
                             onclick="handleRepositoryClick(event, '${group}')">
                            <div style="display: flex; align-items: center;">
                                <span class="chevron"></span>
                                <span>${group}</span>
                            </div>
                            <span class="project-count">${projectCount}</span>
                        </div>
                        <div class="project-list">
                `;
                
                // Sort projects by name within each repository
                projects.sort((a, b) => a.name.localeCompare(b.name)).forEach(project => {
                    const packagingBadge = project.packaging === 'war' 
                        ? '<span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-left: 5px;">WAR</span>'
                        : '<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-left: 5px;">JAR</span>';
                    const isSelected = selectedProject === project.id ? 'selected' : '';
                    projectHtml += `
                        <div class="project-item ${isSelected}" style="border-left-color: ${color(group)}" 
                             onclick="filterByProject('${project.id}')" data-project-id="${project.id}">
                            ${project.name} (${project.version}) ${packagingBadge}
                        </div>
                    `;
                });
                
                projectHtml += `
                        </div>
                    </div>
                `;
            });
            
            projectList.innerHTML = projectHtml;
        }
        
        function filterByProject(projectId) {
            console.log('Filtering by project:', projectId);
            selectedProject = projectId;
            
            // Find all related nodes including transitive dependencies
            const relatedNodes = findTransitiveDependencies(projectId);
            
            console.log('Related nodes (including transitive):', Array.from(relatedNodes));
            
            // Update node visibility
            d3.selectAll('.node').classed('filtered-out', function(d) {
                return !relatedNodes.has(d.id);
            });
            
            // Update link visibility
            d3.selectAll('.link').classed('filtered-out', function(d) {
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                return !relatedNodes.has(sourceId) || !relatedNodes.has(targetId);
            });
            
            // Update sidebar to show selected state
            updateSidebar(currentData, d3.scaleOrdinal(d3.schemeCategory10));
            
            // Center and zoom to filtered nodes
            centerOnFilteredNodes(relatedNodes);
        }
        
        function findTransitiveDependencies(projectId) {
            const relatedNodes = new Set();
            const toProcess = [projectId];
            const processed = new Set();
            
            // Build adjacency lists for efficient traversal
            const dependencies = new Map(); // project -> its dependencies
            const dependents = new Map();   // project -> projects that depend on it
            
            d3.selectAll('.link').each(function(d) {
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                
                // Build dependencies map
                if (!dependencies.has(sourceId)) {
                    dependencies.set(sourceId, new Set());
                }
                dependencies.get(sourceId).add(targetId);
                
                // Build dependents map
                if (!dependents.has(targetId)) {
                    dependents.set(targetId, new Set());
                }
                dependents.get(targetId).add(sourceId);
            });
            
            // Process nodes using BFS to find all transitive dependencies
            while (toProcess.length > 0) {
                const currentId = toProcess.shift();
                
                if (processed.has(currentId)) {
                    continue;
                }
                
                processed.add(currentId);
                relatedNodes.add(currentId);
                
                // Add all dependencies (forward direction)
                if (dependencies.has(currentId)) {
                    for (const depId of dependencies.get(currentId)) {
                        if (!processed.has(depId)) {
                            toProcess.push(depId);
                            console.log(`Transitive dependency: ${currentId} -> ${depId}`);
                        }
                    }
                }
                
                // Add all dependents (backward direction)
                if (dependents.has(currentId)) {
                    for (const depId of dependents.get(currentId)) {
                        if (!processed.has(depId)) {
                            toProcess.push(depId);
                            console.log(`Transitive dependent: ${depId} -> ${currentId}`);
                        }
                    }
                }
            }
            
            return relatedNodes;
        }
        
        function filterByRepository(repository) {
            console.log('Filtering by repository:', repository);
            selectedProject = `group:${repository}`;
            
            // Find all nodes in this repository
            const repoNodes = new Set();
            d3.selectAll('.node').each(function(d) {
                if (d.nodeGroup === repository) {
                    console.log('Found node in repo:', d.id);
                    repoNodes.add(d.id);
                }
            });
            
            console.log('Repository nodes:', Array.from(repoNodes));
            
            // Update node visibility - only show nodes from this repository
            d3.selectAll('.node').classed('filtered-out', function(d) {
                return d.nodeGroup !== repository;
            });
            
            // Update link visibility - show links where both source and target are in the repository
            d3.selectAll('.link').classed('filtered-out', function(d) {
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                
                // Find source and target nodes
                let sourceInRepo = false;
                let targetInRepo = false;
                
                d3.selectAll('.node').each(function(nodeData) {
                    if (nodeData.id === sourceId && nodeData.nodeGroup === repository) {
                        sourceInRepo = true;
                    }
                    if (nodeData.id === targetId && nodeData.nodeGroup === repository) {
                        targetInRepo = true;
                    }
                });
                
                // Only show links where both nodes are in the repository
                return !(sourceInRepo && targetInRepo);
            });
            
            // Update sidebar to show selected state
            updateSidebar(currentData, d3.scaleOrdinal(d3.schemeCategory10));
            
            // Center and zoom to filtered nodes (only repository nodes)
            centerOnFilteredNodes(repoNodes);
        }
        
        function clearFilter() {
            selectedProject = null;
            d3.selectAll('.node').classed('filtered-out', false);
            d3.selectAll('.link').classed('filtered-out', false);
            updateSidebar(currentData, d3.scaleOrdinal(d3.schemeCategory10));
            
            // Reset zoom to show all nodes
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
        }
        
        function handleRepositoryClick(event, repository) {
            // Check if clicking on chevron area (left 40px)
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX - rect.left;
            
            if (x < 40) {
                // Toggle collapse/expand
                event.stopPropagation();
                const repoId = `repo-${repository.replace(/[^a-zA-Z0-9]/g, '-')}`;
                const repoGroup = document.getElementById(repoId);
                const header = repoGroup.querySelector('.repository-header');
                
                repoGroup.classList.toggle('collapsed');
                header.classList.toggle('collapsed');
            } else {
                // Filter by repository
                filterByRepository(repository);
            }
        }
        
        function centerOnFilteredNodes(nodeIds) {
            console.log('Centering on nodes:', Array.from(nodeIds));
            
            // Show centering indicator
            const indicator = document.getElementById('centeringIndicator');
            indicator.style.display = 'block';
            
            // Force simulation to run a bit if needed
            if (simulation.alpha() < 0.1) {
                simulation.alpha(0.3).restart();
            }
            
            // Wait for simulation to stabilize more
            setTimeout(() => {
                // Get the positions of all visible nodes
                const visibleNodes = [];
                d3.selectAll('.node').each(function(d) {
                    if (nodeIds.has(d.id) && d.x !== undefined && d.y !== undefined && !isNaN(d.x) && !isNaN(d.y)) {
                        visibleNodes.push({
                            x: d.x,
                            y: d.y,
                            id: d.id
                        });
                    }
                });
                
                console.log('Visible nodes with positions:', visibleNodes);
                
                if (visibleNodes.length === 0) {
                    console.log('No visible nodes with valid positions found');
                    // Hide indicator after a delay
                    setTimeout(() => {
                        const indicator = document.getElementById('centeringIndicator');
                        indicator.style.display = 'none';
                    }, 1000);
                    // Try again after more time
                    setTimeout(() => centerOnFilteredNodes(nodeIds), 500);
                    return;
                }
                
                // Calculate bounding box
                const minX = Math.min(...visibleNodes.map(n => n.x));
                const maxX = Math.max(...visibleNodes.map(n => n.x));
                const minY = Math.min(...visibleNodes.map(n => n.y));
                const maxY = Math.max(...visibleNodes.map(n => n.y));
                
                // Add minimal padding based on number of nodes
                let boxPadding = 30;
                if (visibleNodes.length === 1) {
                    boxPadding = 50; // Small padding for single node
                } else if (visibleNodes.length <= 5) {
                    boxPadding = 40; // Small padding for small groups
                }
                
                const adjustedMinX = minX - boxPadding;
                const adjustedMaxX = maxX + boxPadding;
                const adjustedMinY = minY - boxPadding;
                const adjustedMaxY = maxY + boxPadding;
                
                // Calculate center and dimensions
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const width = adjustedMaxX - adjustedMinX;
                const height = adjustedMaxY - adjustedMinY;
                
                console.log('Bounding box:', { minX: adjustedMinX, maxX: adjustedMaxX, minY: adjustedMinY, maxY: adjustedMaxY });
                console.log('Center:', { centerX, centerY });
                console.log('Dimensions:', { width, height });
                
                // Get SVG dimensions
                const svgElement = svg.node();
                const svgRect = svgElement.getBoundingClientRect();
                const svgWidth = svgRect.width;
                const svgHeight = svgRect.height;
                
                console.log('SVG dimensions:', { svgWidth, svgHeight });
                
                // Calculate scale to fit all nodes with much closer zoom
                let scale = 1;
                
                if (width > 0 && height > 0) {
                    const scaleX = svgWidth / width;
                    const scaleY = svgHeight / height;
                    scale = Math.min(scaleX, scaleY) * 0.95; // 95% to maximize zoom
                    
                    // Apply much higher scale limits for closer view
                    if (visibleNodes.length === 1) {
                        // Single node: zoom very close
                        scale = Math.max(3.0, Math.min(scale, 5.0));
                    } else if (visibleNodes.length <= 3) {
                        // 2-3 nodes: zoom close
                        scale = Math.max(2.5, Math.min(scale, 4.0));
                    } else if (visibleNodes.length <= 10) {
                        // 4-10 nodes: zoom moderately close
                        scale = Math.max(1.5, Math.min(scale, 3.0));
                    } else if (visibleNodes.length <= 20) {
                        // 11-20 nodes: zoom somewhat close
                        scale = Math.max(1.0, Math.min(scale, 2.5));
                    } else {
                        // Many nodes: still zoom in but not too much
                        scale = Math.max(0.8, Math.min(scale, 2.0));
                    }
                }
                
                console.log('Calculated scale:', scale);
                
                // Get current transform to smoothly transition
                const currentTransform = d3.zoomTransform(svg.node());
                
                // Apply transform with animation
                try {
                    const transform = d3.zoomIdentity
                        .translate(svgWidth / 2, svgHeight / 2)
                        .scale(scale)
                        .translate(-centerX, -centerY);
                    
                    console.log('Final transform:', {
                        translateX: svgWidth / 2 - centerX * scale,
                        translateY: svgHeight / 2 - centerY * scale,
                        scale: scale
                    });
                    
                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, transform)
                        .on('end', () => {
                            console.log('Centering animation completed');
                            // Hide centering indicator
                            const indicator = document.getElementById('centeringIndicator');
                            indicator.style.display = 'none';
                        })
                        .on('interrupt', () => {
                            console.log('Centering animation interrupted');
                            const indicator = document.getElementById('centeringIndicator');
                            indicator.style.display = 'none';
                        });
                } catch (error) {
                    console.error('Error applying zoom transform:', error);
                    // Fallback: just hide the indicator
                    const indicator = document.getElementById('centeringIndicator');
                    indicator.style.display = 'none';
                    
                    // Try a simpler zoom
                    try {
                        const simpleTransform = d3.zoomIdentity.scale(1.5);
                        svg.call(zoom.transform, simpleTransform);
                    } catch (e) {
                        console.error('Even simple zoom failed:', e);
                    }
                }
            }, 800); // Wait 800ms for force simulation to position nodes better
        }
        
        
        // Debug function to check current state
        function debugZoomState() {
            const transform = d3.zoomTransform(svg.node());
            const visibleNodes = [];
            d3.selectAll('.node:not(.filtered-out)').each(function(d) {
                visibleNodes.push({
                    id: d.id,
                    x: d.x,
                    y: d.y
                });
            });
            
            console.log('Current zoom state:', {
                transform: {
                    x: transform.x,
                    y: transform.y,
                    scale: transform.k
                },
                visibleNodes: visibleNodes.length,
                selectedProject: selectedProject
            });
        }
        
        // Calculate repository positions to avoid overlaps
        function calculateRepositoryPositions(projectsByRepo, width, height) {
            const repos = Object.entries(projectsByRepo);
            const repoCount = repos.length;
            const positions = {};
            
            // Sort repositories by project count (larger ones first)
            repos.sort((a, b) => b[1].length - a[1].length);
            
            // Use pack layout for better space utilization
            const margin = 150;
            const effectiveWidth = width - 2 * margin;
            const effectiveHeight = height - 2 * margin;
            
            // Calculate optimal grid dimensions
            const aspectRatio = effectiveWidth / effectiveHeight;
            let cols = Math.ceil(Math.sqrt(repoCount * aspectRatio));
            let rows = Math.ceil(repoCount / cols);
            
            // Minimum spacing between repository centers
            const minSpacing = 250;
            
            // Calculate cell dimensions
            const cellWidth = Math.max(minSpacing, effectiveWidth / cols);
            const cellHeight = Math.max(minSpacing, effectiveHeight / rows);
            
            // If cells are too small, reduce columns
            if (cellWidth < minSpacing || cellHeight < minSpacing) {
                cols = Math.floor(effectiveWidth / minSpacing);
                rows = Math.ceil(repoCount / cols);
            }
            
            // Assign positions with guaranteed spacing
            repos.forEach(([repo, projects], index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                
                // Add some randomness to prevent perfect grid alignment
                const jitterX = (Math.random() - 0.5) * 20;
                const jitterY = (Math.random() - 0.5) * 20;
                
                positions[repo] = {
                    x: margin + col * cellWidth + cellWidth / 2 + jitterX,
                    y: margin + row * cellHeight + cellHeight / 2 + jitterY,
                    projects: projects.length,
                    radius: projects.length > 1 ? 80 : 50 // Estimated radius for collision detection
                };
            });
            
            return positions;
        }
        
        // Enforce repository separation to prevent overlaps
        function enforceRepositorySeparation() {
            if (!currentData) return;
            
            // Group nodes by repository
            const repoGroups = {};
            currentData.nodes.forEach(node => {
                if (!repoGroups[node.nodeGroup]) {
                    repoGroups[node.nodeGroup] = [];
                }
                repoGroups[node.nodeGroup].push(node);
            });
            
            // Calculate center of each repository group
            const repoCenters = {};
            Object.entries(repoGroups).forEach(([repo, nodes]) => {
                const avgX = nodes.reduce((sum, n) => sum + n.x, 0) / nodes.length;
                const avgY = nodes.reduce((sum, n) => sum + n.y, 0) / nodes.length;
                repoCenters[repo] = { x: avgX, y: avgY, nodes: nodes };
            });
            
            // Check for overlaps and adjust - multiple iterations
            const repos = Object.entries(repoCenters);
            const iterations = 5; // Multiple passes to ensure separation
            
            for (let iter = 0; iter < iterations; iter++) {
                let moved = false;
                
                for (let i = 0; i < repos.length; i++) {
                    for (let j = i + 1; j < repos.length; j++) {
                        const [repo1, center1] = repos[i];
                        const [repo2, center2] = repos[j];
                        
                        // Calculate current positions
                        const c1x = center1.nodes.reduce((sum, n) => sum + n.x, 0) / center1.nodes.length;
                        const c1y = center1.nodes.reduce((sum, n) => sum + n.y, 0) / center1.nodes.length;
                        const c2x = center2.nodes.reduce((sum, n) => sum + n.x, 0) / center2.nodes.length;
                        const c2y = center2.nodes.reduce((sum, n) => sum + n.y, 0) / center2.nodes.length;
                        
                        const dx = c2x - c1x;
                        const dy = c2y - c1y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Calculate required distance based on repository sizes
                        const radius1 = Math.max(80, center1.nodes.length * 30);
                        const radius2 = Math.max(80, center2.nodes.length * 30);
                        const minDistance = radius1 + radius2 + 100; // Add padding
                        
                        if (distance < minDistance && distance > 0) {
                            moved = true;
                            
                            // Move repositories apart
                            const angle = Math.atan2(dy, dx);
                            const moveDistance = (minDistance - distance) / 2 + 10;
                            
                            // Move repo1 nodes
                            const move1X = -moveDistance * Math.cos(angle);
                            const move1Y = -moveDistance * Math.sin(angle);
                            center1.nodes.forEach(node => {
                                node.x += move1X;
                                node.y += move1Y;
                            });
                            
                            // Move repo2 nodes
                            const move2X = moveDistance * Math.cos(angle);
                            const move2Y = moveDistance * Math.sin(angle);
                            center2.nodes.forEach(node => {
                                node.x += move2X;
                                node.y += move2Y;
                            });
                            
                            // Update centers for next iteration
                            center1.x = c1x + move1X;
                            center1.y = c1y + move1Y;
                            center2.x = c2x + move2X;
                            center2.y = c2y + move2Y;
                        }
                    }
                }
                
                if (!moved) break; // No overlaps found
            }
            
            // Update node positions in the visualization
            d3.selectAll('.node').attr("transform", d => `translate(${d.x},${d.y})`);
            d3.selectAll('.link')
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
        }
        
        // Function to manually separate overlapping groups
        function separateOverlappingGroups() {
            console.log('Separating overlapping repository groups...');
            
            // Reset grid layout mode and data
            isGridLayout = false;
            gridParameters = null;
            repositoryLayoutData = [];
            
            // Stop the simulation temporarily
            simulation.stop();
            
            // Apply separation
            enforceRepositorySeparation();
            
            // Redraw repository groups
            forceUpdateGroups();
            
            // Restart simulation with low alpha to fine-tune positions
            simulation.alpha(0.1).restart();
            
            // Status update
            document.getElementById('group-status').textContent = 'Groups separated';
            
            setTimeout(() => {
                document.getElementById('group-status').textContent = 
                    groupsVisible ? `Showing ${Object.keys(currentData ? currentData.nodes.reduce((acc, n) => {acc[n.nodeGroup] = 1; return acc;}, {}) : {}).length} repository groups` : 'Repository groups hidden';
            }, 2000);
        }
        
        // Use fixed grid layout to completely avoid overlaps
        function useFixedLayout() {
            if (!currentData) return;
            
            console.log('Applying fixed grid layout...');
            
            // Set grid layout flag
            isGridLayout = true;
            
            // Stop simulation temporarily
            if (simulation) {
                simulation.stop();
            }
            
            // Group nodes by repository
            const repoGroups = {};
            currentData.nodes.forEach(node => {
                if (!repoGroups[node.nodeGroup]) {
                    repoGroups[node.nodeGroup] = [];
                }
                repoGroups[node.nodeGroup].push(node);
            });
            
            // Sort repos by project count for better visual organization
            const repos = Object.entries(repoGroups).sort((a, b) => b[1].length - a[1].length);
            const repoCount = repos.length;
            
            console.log(`Arranging ${repoCount} repositories in fixed grid`);
            
            // Calculate SVG dimensions
            const svg = d3.select("#graph");
            const svgWidth = svg.node().parentElement.clientWidth;
            const svgHeight = svg.node().parentElement.clientHeight;
            
            // Fixed grid parameters with larger spacing
            const cols = 6; // Reduce columns for more space
            const rows = Math.ceil(repoCount / cols);
            const cellWidth = 250;  // Fixed larger cell width
            const cellHeight = 180; // Fixed larger cell height
            const cellPadding = 30; // Larger padding inside each cell
            
            // Calculate total grid size
            const gridWidth = cols * cellWidth;
            const gridHeight = rows * cellHeight;
            
            // Center the grid in the SVG with minimum margins
            const minMargin = 50;
            const offsetX = Math.max(minMargin, (svgWidth - gridWidth) / 2);
            const offsetY = Math.max(minMargin, (svgHeight - gridHeight) / 2);
            
            // Store grid parameters for use in forceUpdateGroups
            gridParameters = {
                cols: cols,
                rows: rows,
                cellWidth: cellWidth,
                cellHeight: cellHeight,
                offsetX: offsetX,
                offsetY: offsetY,
                repoIndexMap: {} // Map repository name to grid index
            };
            
            // Clear all existing fixed positions first
            currentData.nodes.forEach(node => {
                delete node.fx;
                delete node.fy;
            });
            
            // Clear and rebuild repository layout data
            repositoryLayoutData = [];
            
            // Position each repository in its cell
            repos.forEach(([repo, nodes], index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                // Store repository index in map
                gridParameters.repoIndexMap[repo] = index;
                
                // Calculate cell bounds
                const cellLeft = offsetX + col * cellWidth;
                const cellTop = offsetY + row * cellHeight;
                const cellCenterX = cellLeft + cellWidth / 2;
                const cellCenterY = cellTop + cellHeight / 2;
                
                // Calculate rectangle bounds for this repository with larger margins
                const cellMargin = 20; // Much larger margin to ensure no overlap
                const rectBounds = {
                    x: cellLeft + cellMargin,
                    y: cellTop + cellMargin,
                    width: cellWidth - 2 * cellMargin,
                    height: cellHeight - 2 * cellMargin
                };
                
                // Add to repository layout data
                repositoryLayoutData.push({
                    name: repo,
                    nodes: nodes,
                    rect: rectBounds
                });
                
                // Position nodes within the cell
                if (nodes.length === 1) {
                    // Single node - center it
                    nodes[0].x = cellCenterX;
                    nodes[0].y = cellCenterY;
                    nodes[0].fx = cellCenterX; // Fix position
                    nodes[0].fy = cellCenterY;
                } else {
                    // Multiple nodes - arrange in circle with smaller radius
                    const maxRadius = Math.min(cellWidth, cellHeight) / 2 - cellPadding - 20; // Extra margin
                    const radius = Math.min(maxRadius, 15 + 3 * Math.sqrt(nodes.length)); // Smaller radius
                    
                    nodes.forEach((node, i) => {
                        const angle = (i * 2 * Math.PI) / nodes.length - Math.PI / 2;
                        node.x = cellCenterX + radius * Math.cos(angle);
                        node.y = cellCenterY + radius * Math.sin(angle);
                        node.fx = node.x; // Fix position
                        node.fy = node.y;
                    });
                }
            });
            
            // Update node positions immediately
            d3.selectAll('.node')
                .transition()
                .duration(750)
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on('end', function() {
                    // Ensure positions are maintained after transition
                    d3.select(this).attr("transform", d => `translate(${d.x},${d.y})`);
                });
            
            // Update link positions
            d3.selectAll('.link')
                .transition()
                .duration(750)
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            
            // Force update groups after positions are set
            setTimeout(() => {
                forceUpdateGroups();
                document.getElementById('group-status').textContent = `Grid layout: ${cols}${rows} (${repoCount} repositories)`;
                
                // Double-check positions are maintained
                d3.selectAll('.node').attr("transform", d => `translate(${d.x},${d.y})`);
                d3.selectAll('.link')
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                // Stop simulation completely to prevent shaking
                if (simulation) {
                    simulation.stop();
                }
                
                // Zoom out to show all repositories if needed
                const totalWidth = cols * cellWidth + 100;
                const totalHeight = rows * cellHeight + 100;
                if (totalWidth > svgWidth || totalHeight > svgHeight) {
                    const scaleX = svgWidth / totalWidth;
                    const scaleY = svgHeight / totalHeight;
                    const scale = Math.min(scaleX, scaleY) * 0.9; // 90% to add some padding
                    
                    const transform = d3.zoomIdentity
                        .translate(svgWidth / 2, svgHeight / 2)
                        .scale(scale)
                        .translate(-svgWidth / 2, -svgHeight / 2);
                    
                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, transform);
                }
            }, 800);
        }
        
        // Export debug functions for testing
        window.debugZoomState = debugZoomState;
        window.debugRepositoryLayout = function() {
            console.log('Repository Layout Data:', repositoryLayoutData);
            console.log('Is Grid Layout:', isGridLayout);
            console.log('Grid Parameters:', gridParameters);
        };
        
        // Custom force to keep nodes within their repository bounds
        function forceRepositoryBounds() {
            let nodes;
            
            function force() {
                nodes.forEach(node => {
                    // Find the repository bounds for this node
                    const repoBounds = repositoryLayoutData.find(r => r.name === node.nodeGroup);
                    if (repoBounds) {
                        const rect = repoBounds.rect;
                        const padding = 15; // Keep nodes away from edges
                        
                        // Constrain x position
                        if (node.x < rect.x + padding) {
                            node.x = rect.x + padding;
                            node.vx = Math.abs(node.vx) * 0.5; // Bounce effect
                        } else if (node.x > rect.x + rect.width - padding) {
                            node.x = rect.x + rect.width - padding;
                            node.vx = -Math.abs(node.vx) * 0.5;
                        }
                        
                        // Constrain y position
                        if (node.y < rect.y + padding + 20) { // Extra space for label
                            node.y = rect.y + padding + 20;
                            node.vy = Math.abs(node.vy) * 0.5;
                        } else if (node.y > rect.y + rect.height - padding) {
                            node.y = rect.y + rect.height - padding;
                            node.vy = -Math.abs(node.vy) * 0.5;
                        }
                    }
                });
            }
            
            force.initialize = function(_) {
                nodes = _;
            };
            
            return force;
        }
        
        // Repository groups are always visible
        
        
        // Check if two rectangles overlap
        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.x + rect1.width < rect2.x || 
                     rect2.x + rect2.width < rect1.x || 
                     rect1.y + rect1.height < rect2.y || 
                     rect2.y + rect2.height < rect1.y);
        }
        
        // Find a valid position for a rectangle that doesn't overlap with others
        function findNonOverlappingPosition(movingRect, movingIndex, allRects, originalX, originalY) {
            // Check if current position is valid
            let overlaps = false;
            for (let i = 0; i < allRects.length; i++) {
                if (i !== movingIndex && rectanglesOverlap(movingRect, allRects[i].rect)) {
                    overlaps = true;
                    break;
                }
            }
            
            if (!overlaps) {
                return { x: movingRect.x, y: movingRect.y };
            }
            
            // If overlapping, try to find nearest valid position
            const directions = [
                { dx: 0, dy: -10 },  // up
                { dx: 10, dy: 0 },   // right
                { dx: 0, dy: 10 },   // down
                { dx: -10, dy: 0 },  // left
            ];
            
            let distance = 10;
            const maxDistance = 500;
            
            while (distance < maxDistance) {
                for (const dir of directions) {
                    const testRect = {
                        x: originalX + dir.dx * distance / 10,
                        y: originalY + dir.dy * distance / 10,
                        width: movingRect.width,
                        height: movingRect.height
                    };
                    
                    let valid = true;
                    for (let i = 0; i < allRects.length; i++) {
                        if (i !== movingIndex && rectanglesOverlap(testRect, allRects[i].rect)) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) {
                        return { x: testRect.x, y: testRect.y };
                    }
                }
                distance += 10;
            }
            
            // If no valid position found, return original
            return { x: originalX, y: originalY };
        }
        
        // Repository frame drag functions
        function framesDragstarted(event, d) {
            const container = d3.select(this);
            container.raise();
            container.select(".repo-group").classed("dragging", true);
            
            // Store starting positions
            d.dragStartX = event.x;
            d.dragStartY = event.y;
            d.rectStartX = d.rect.x;
            d.rectStartY = d.rect.y;
            
            // Store original positions of all nodes
            d.nodes.forEach(node => {
                node.dragStartX = node.x;
                node.dragStartY = node.y;
            });
        }
        
        function framesDragged(event, d) {
            const dx = event.x - d.dragStartX;
            const dy = event.y - d.dragStartY;
            
            // Update rect position
            const newX = d.rectStartX + dx;
            const newY = d.rectStartY + dy;
            
            // Create test rectangle
            const testRect = {
                x: newX,
                y: newY,
                width: d.rect.width,
                height: d.rect.height
            };
            
            // Check if position would cause collision
            let wouldCollide = false;
            for (let i = 0; i < repositoryLayoutData.length; i++) {
                if (repositoryLayoutData[i] !== d && rectanglesOverlap(testRect, repositoryLayoutData[i].rect)) {
                    wouldCollide = true;
                    break;
                }
            }
            
            // Update visual collision feedback
            const container = d3.select(this);
            container.select(".repo-group").classed("collision-warning", wouldCollide);
            
            // Check for collisions and get valid position
            const validPos = findNonOverlappingPosition(
                testRect, 
                repositoryLayoutData.indexOf(d),
                repositoryLayoutData,
                newX,
                newY
            );
            
            // Update data
            d.rect.x = validPos.x;
            d.rect.y = validPos.y;
            
            // Update visual elements
            container.select(".repo-group")
                .attr("x", d.rect.x)
                .attr("y", d.rect.y);
            
            // Update label position
            const labelY = isGridLayout ? d.rect.y + 5 : d.rect.y - 30;
            const labelTextY = isGridLayout ? d.rect.y + 23 : d.rect.y - 12;
            
            container.select(".repo-group-label")
                .attr("x", d.rect.x + 10)
                .attr("y", labelTextY);
            
            container.select("rect:nth-child(2)") // label background
                .attr("x", d.rect.x + 5)
                .attr("y", labelY);
            
            // Move all nodes within this repository
            d.nodes.forEach(node => {
                const relX = node.dragStartX - d.rectStartX;
                const relY = node.dragStartY - d.rectStartY;
                node.x = d.rect.x + relX;
                node.y = d.rect.y + relY;
                node.fx = node.x;
                node.fy = node.y;
            });
            
            // Update node positions immediately
            d3.selectAll('.node')
                .filter(n => d.nodes.includes(n))
                .attr("transform", n => `translate(${n.x},${n.y})`);
            
            // Update links manually without restarting simulation
            d3.selectAll('.link')
                .attr("d", linkData => {
                    const sourceNode = linkData.source;
                    const targetNode = linkData.target;
                    
                    if (!sourceNode || !targetNode) return "";
                    
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Different curves for internal vs external links
                    if (sourceNode.nodeGroup === targetNode.nodeGroup) {
                        // Internal links: smaller curves
                        const dr = distance * 0.5;
                        return `M${sourceNode.x},${sourceNode.y} Q${(sourceNode.x + targetNode.x) / 2},${(sourceNode.y + targetNode.y) / 2 + dr / 3} ${targetNode.x},${targetNode.y}`;
                    } else {
                        // External links: larger curves for better separation
                        const dr = distance * 0.8;
                        // Add slight offset based on link direction to separate bidirectional links
                        const offset = sourceNode.id < targetNode.id ? -10 : 10;
                        const midX = (sourceNode.x + targetNode.x) / 2 + offset * dy / distance;
                        const midY = (sourceNode.y + targetNode.y) / 2 - offset * dx / distance;
                        return `M${sourceNode.x},${sourceNode.y} Q${midX},${midY + dr / 2} ${targetNode.x},${targetNode.y}`;
                    }
                });
        }
        
        function framesDragended(event, d) {
            const container = d3.select(this);
            container.select(".repo-group")
                .classed("dragging", false)
                .classed("collision-warning", false);
            
            // Fix node positions in new location
            d.nodes.forEach(node => {
                node.fx = node.x;
                node.fy = node.y;
            });
            
            // Update the repositoryBounds force to use new positions
            simulation.force("repositoryBounds").initialize(simulation.nodes());
        }
        
        // Force update groups function
        function forceUpdateGroups() {
            if (!currentData || !groupsVisible) return;
            
            let repositoriesToDraw;
            
            if (isGridLayout && repositoryLayoutData.length > 0) {
                // Use the pre-calculated repository layout data
                repositoriesToDraw = repositoryLayoutData;
                console.log('Using pre-calculated layout data for', repositoriesToDraw.length, 'repositories');
            } else {
                // Fallback to dynamic calculation for non-grid layouts
                const projectsByRepo = {};
                currentData.nodes.forEach(node => {
                    if (!projectsByRepo[node.nodeGroup]) {
                        projectsByRepo[node.nodeGroup] = [];
                    }
                    projectsByRepo[node.nodeGroup].push(node);
                });
                
                // Create repository objects with dynamic bounds
                repositoriesToDraw = Object.entries(projectsByRepo).map(([repo, projects]) => {
                    // Skip if positions not initialized
                    if (projects.some(n => n.x === undefined || n.y === undefined)) {
                        return null;
                    }
                    
                    // Calculate bounding box with appropriate padding
                    const padding = projects.length > 1 ? 40 : 25;
                    const xs = projects.map(n => n.x);
                    const ys = projects.map(n => n.y);
                    
                    return {
                        name: repo,
                        nodes: projects,
                        rect: {
                            x: Math.min(...xs) - padding,
                            y: Math.min(...ys) - padding,
                            width: Math.max(...xs) - Math.min(...xs) + 2 * padding,
                            height: Math.max(...ys) - Math.min(...ys) + 2 * padding
                        }
                    };
                }).filter(r => r !== null);
            }
            
            console.log('Force updating groups for repositories:', repositoriesToDraw.length);
            
            // Clear existing groups from both layers
            d3.select(".groups-layer").selectAll("*").remove();
            d3.select(".static-groups-layer").selectAll("*").remove();
            
            // Use static layer for grid layout, dynamic layer otherwise
            const groupsLayer = isGridLayout ? d3.select(".static-groups-layer") : d3.select(".groups-layer");
            
            repositoriesToDraw.forEach(repoData => {
                const { name: repo, nodes, rect } = repoData;
                
                // Skip if nodes don't have positions (for dynamic mode)
                if (!isGridLayout && nodes.some(n => n.x === undefined || n.y === undefined)) {
                    console.log('Skipping', repo, '- positions not initialized');
                    return;
                }
                
                // Create group container with data and drag behavior
                const groupContainer = groupsLayer.append("g")
                    .attr("class", "repo-group-container")
                    .datum(repoData)
                    .call(d3.drag()
                        .on("start", framesDragstarted)
                        .on("drag", framesDragged)
                        .on("end", framesDragended));
                
                // Draw rectangle with enhanced styles
                const rectElement = groupContainer.append("rect")
                    .attr("class", "repo-group")
                    .attr("x", rect.x)
                    .attr("y", rect.y)
                    .attr("width", rect.width)
                    .attr("height", rect.height)
                    .attr("rx", 20)
                    .attr("ry", 20);
                
                if (nodes.length > 1) {
                    // Multi-project repositories: dashed border
                    rectElement.style("fill", "#f5f5f5")
                        .style("fill-opacity", 0.9)
                        .style("stroke", "#666666")
                        .style("stroke-width", "4px")
                        .style("stroke-dasharray", "15,5");
                } else {
                    // Single-project repositories: solid border
                    rectElement.style("fill", "#f5f5f5")
                        .style("fill-opacity", 0.7)
                        .style("stroke", "#757575")
                        .style("stroke-width", "2px")
                        .style("stroke-dasharray", "none");
                }
                
                // Add label with background
                const labelY = isGridLayout ? rect.y + 5 : rect.y - 30; // Inside for grid, outside for normal
                const labelTextY = isGridLayout ? rect.y + 23 : rect.y - 12;
                
                const labelBg = groupContainer.append("rect")
                    .attr("x", rect.x + 5)
                    .attr("y", labelY)
                    .attr("rx", 5)
                    .attr("ry", 5)
                    .style("fill", "white")
                    .style("stroke", "#666666")
                    .style("stroke-width", "2px");
                
                const label = groupContainer.append("text")
                    .attr("class", "repo-group-label")
                    .attr("x", rect.x + 10)
                    .attr("y", labelTextY)
                    .text(repo)
                    .style("font-size", isGridLayout ? "14px" : "18px") // Smaller font for grid
                    .style("font-weight", "bold")
                    .style("fill", "#333333");
                
                // Adjust background to fit text
                const bbox = label.node().getBBox();
                labelBg
                    .attr("width", bbox.width + 10)
                    .attr("height", bbox.height + 6)
                    .attr("x", bbox.x - 5)
                    .attr("y", bbox.y - 3);
            });
            
            // Update status
            document.getElementById('group-status').textContent = '';
            
            console.log('Repository groups updated');
        }
        
    </script>
</body>
</html>